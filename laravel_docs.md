# Лара бля...

Значит так, директории делятся на два типа:

### The Root Directory
  The app Directory
  The bootstrap Directory
  The config Directory
  The database Directory
  The public Directory
  The resources Directory
  The routes Directory
  The storage Directory
  The tests Directory
  The vendor Directory

### The App Directory
  The Broadcasting Directory
  The Console Directory
  The Events Directory
  The Exceptions Directory
  The Http Directory
  The Jobs Directory
  The Listeners Directory
  The Mail Directory
  The Models Directory
  The Notifications Directory
  The Policies Directory
  The Providers Directory
  The Rules Directory


ух бля... ну погнали

начинаем с рута

* директория **app** содержит в себе ядро кода нашего приложения. Почти все классы в твоем приложении будут находиться именно там.

* директория **bootstrap** содержит файл *app.php*, который автозагружает фреймворк (?). Также в этой директории поселилась **cache** директория, ну она для оптимизации типа понятное дело. Тебе здесь не рады, ничего здесь не меняй.

* директория **config**, по названию уже понятно, что в себе содержит. Действительно, было бы неплохо если бы ты туда заглянул посмотрел, но... идем дальше

* директория **database** содержит в себе миграции бд, заводы модельные (ну вроде типа чтобы заполнить данными). Также можно там держать SQLite базу данных.

* **public** содержит *index.php* файл, который является входной точкой для всех реквестов, входящих в твое приложение и настраивает автозагрузку. В этом каталоге так же хранятся различные ассеты по типу картинок, js css. 

* **resources** содержит views (представления), а также сырые, некомпилированные ассеты по типу css и js.

* **routes** содержит все определения маршрутов приложения. По дефолту, в ларавеле включено несклько маршрутов: web.php, api.php, console.php и channels.php

  + **web.php** содержит маршруты, которые RouteServiceProvider помещает в группу веб-промежуточного ПО (web middleware), которое обеспечивает состояние сессии (?), CSRF защиту и шифрование куки. Если моё приложение не предлагает stateless, RESTful API, тогда все мои руты скорее всего будут определены именно в **web.php**.

  + **api.php** содержит маршруты, которые RouteServiceProvider помещает в группу *api middleware*. Эти маршруты предназначены для того, чтобы быть *stateless* (ааа, stateless это значит, что состояние не хранится на сервере), поэтому реквесты, заходящие в приложение через эти маршруты должны быть авторизованы через токены и не будут иметь доступ к session state (состояние сессии(?)).

  + **console.php** - файл, где мы определяем все наши замыкания, основанные на консольных командах. Каждое замыкание привязано к экземпляру команды, что обеспечивает простой подход к взаимодействию с методами ввода-вывода (IO methods) каждой команды. Несмотря на то, что этот файл не определяет HTTP маршруты, он определяет основанные на консоли входные точки (маршруты) в твоём приложении.

  + **channels.php** - файл, где можно зарегистрировать все каналы трансляции событий, которые поддерживает наше приложение.

* **storage** содержит логи, blade шаблоны скомпилированные, сессии (file based), кэш и многое другое, сгенерированное фреймворком. Ну сральня офк. Директория поделена на app, framework и logs директории. 


КОРОЧЕ, ПОТОМ ДОБИВАЙ ЭТО, Я НАСТОЯЩИЙ СЕЙЧАС ЗАЕБАЛСЯ

## Обзор жизненного цикла (Lyfecycle Overview)

### Первые Шаги

Точкой входа для всех реквестов, направленных на приложение Laravelm, является *public/index.php*. 

Все реквесты направляются в этот файл благодаря конфигурации твоего веб-сервера (Apache, Nginx)

*index.php* загружает сгенерированные Composer-ом определения автозагрузки, и затем получает экземпляр Laravel приложения из файла *bootstrap/app.php*

Первым делом laravel создаст экземпляр приложения / service container

### HTTP / Консольные ядра (Console Kernels)

После первых шагов, входящий запрос отправляется или в HTTP Kernel или в Console Kernel, это зависит типа запроса, который входит в программу (?)
 
Эти карты, деньги, два ядра служат центральной прослойкой, через которую проходят все запросы.
 
HTTP: *app/Http/Kernel.php*
 
* HTTP ядро наследует (extends) класс *Illuminate\Foundation\Http\Kernel*,  который определяет массив из бутстраперов, которые будут запущены перед тем, как выполнится запрос.
 
Бутстраперы конфигурируют error handling, logging, определяют окружение приложения и прочее.

> обычно, эти классы обрабатывают внутреннюю конфигурацию Laravel, о которой нам не нужно беспокоиться

* Также HTTP ядро определяет список *HTTP middleware*, через который все запросы должны пройти перед их обработкой приложением.

* Middleware (промежуточное ПО) обрабатывает чтение и запись HTTP сессии

### Service Providers (Поставщики Услуг)

* Service Providers ответственны за bootstrapping (начальную загрузку) всех компонентов фреймворка, по типу бд, запрос, валидация и прочее. 

Все service providers конфигурируются в *config/app.php* файле, в массиве *providers*

Laravel поэтапно пройдет через этот список провайдеров/поставщиков и создаст экземпляр для каждого/

* Экземпляр класса (instance) - это описание конкретного объекта в памяти

После создания экземпляра провайдеров, будет вызван метод *register* для всех поставщиков.

Затем, после того, ка все провайдеры будут зарегистрированы, метод *boot* будет вызван так же для всех провайдеров. 

Это сделано для того, чтобы service providers могли зависеть от того, что каждая привязка контейнера будет зарегистрирована и доступна к моменту выполнения метода *boot*

Service Providers - самый важный аспект всего Laravel bootstrap процесса.

### Routing (Маршрутизация)

* Service provider *App\Providers\RouteServiceProvider* загружает файлы маршрутов, которые находятся внутри директории *routes* нашего приложения

После того, как приложение было загружено (bootstrapped) и все service providers были зарегистрированы, будет передан *Request* маршрутизатору для отправки.

Маршрутизатор отправит запрос на маршрут (route) или контроллер, а также запустит любое промежуточное ПО (middleware), специфичное для маршрута.

Если запрос пройдет через всё назначенное middleware соответствующего маршрута, метод контроллера или маршрута будет выполнен и ответ, возвращенный методом маршрута или контроллера, будет отправлен обратно через цепочку middleware

### Подвод итогов

Как только маршрутный или контроллерный метод возвращает ответ, ответ отправится в путешествие обратно через маршрутное middleware, давая приложению возможность модифицировать или проверить исходящий ответ. 

Как итог, как только ответ пройдет обратно через middleware, метод handle ядра HTTP возвратит объект ответа, а файл *index.php* вызовет метод *send* на возвращенный ответ. Метод *send* отправляет содержимое ответа в броузер веб-юзера.


Service Providers - поистине ключ к загрузке приложения Laravel: создаётся экземпляр приложения, регистрируются service providers, и запрос передается загруженному приложению

Service providers по умолчанию хранятся в *app/Providers*

AppServiceProvider - место для создания собственных бутстрапперов и биндов. 


## Service Containers

* Service container - инструмент для управления зависимостями класса и выполнения внедрения зависимостей

Внедрение зависимостей - зависимости класса "внедрены" в класс через конструктор или, иногда, с помощью seter методов

### Zero Configuration Resolution (разрешение нулевой конфигурации)

Если у класса нет зависимостей или он зависит только от конкретных классов (не интерфейсов), то контейнеру не нужно указывать, как разрешить этот класс.

```php

<?php
 
class Service
{
    // ...
}
 
Route::get('/', function (Service $service) {
    die($service::class);
});

```

В примере выше переход к маршруту приложения "/" автоматически разрешит класс Service и внедрит его в обработчик вашего маршрута. 

### Когда использовать контейнера

Благодаря нулевому разрешению конфигурации (zero configuration resolution) вы часто будетет указывать зависимости в маршрутах, контроллерах, слушателях событий (event listeners) и других местах, никогда не взаимодействуя с контейнером вручную

Например, можно указать объект Illuminate\Http\Request в route definition (определение маршрута), чтобы легко получить доступ к текущему запросу. Несмотря на то, что нам никогда не придётся взаимодействовать с контейнером для написания этого кода, он управляет внедрением этих зависимостей за кулисами:

```php

  use Illuminate\Http\Request;
 
  Route::get('/', function (Request $request) {
    // ...
});
```

Во многих случаях, благодаря автоматическим зависимостям и [фасадам](https://laravel.com/docs/10.x/facades), можно забилдить Laravel приложение без необходимости вручную связывать или разрешать что-либо из контейнера.

Если ты пишешь класс, реализующий интерфейс, и хочешь указать этот интерфейс в маршруте или конструкторе класа, ты должен указать контейнеру, как 
[разрешить этот интерфейс](https://laravel.com/docs/10.x/container#binding-interfaces-to-implementations)

## Binding (привязка/связывание)

* Контейнер зависимостей - инструмент для управления зависимостями и внедрения зависимостей

* Binding - способ сообщить контейнеру, как создавать экземпляры классов и как ими управлять

Bindind - это как рецепт для создания объекта

* Представим, что есть рецепт (байндинг), чтобы приготовить определённое блюдо (объект). Когда ты хочешь это блюдо, ты следуюешь рецепту, используя нужные ингредиенты (зависимости)

Пример:

Пишем рецепт:
> Если кто-то попросит объект класса А, используй функцию, которая создает его и добавляет нужные ингредиенты

Когда нужен объект, мы говорим контейнеру: Дай мне объект класса А. 

Laravel использует твой рецепт, чтобы приготовить и вернуть тебе объект

Регистрация:

```php

// В файле, где регистрируются байндинги, например, app/Providers/AppServiceProvider.php

use App\Services\MyService;

public function register()
{
    $this->app->bind(MyService::class, function ($app) {
        // Создаем объект MyService и добавляем нужные ингредиенты (зависимости)
        return new MyService($app['SomeDependency']);
    });
}
```

Запрос объекта:

```
// Когда тебе нужен объект MyService
$myService = app(MyService::class);
```

байндинги - это способ управлять объектами. 

Почти все связи (bindings) в контейнере сервисов будут создаваться и настраиваться внутри провайдеров сервисов.


* **Контейнер зависимостей** - это такое хранилище, где Laravel держит информацию о том, как создавать и предоставлять объекты

> если твое приложение говорит "Мне нужен объект класса А", контейнер сервисов отвечает "Понял, создам для тебя объект класса А с учетом всех нужных деталей"

* **Провайдер сервисов** - Это как "мастер-повар", который подготавливаем "рецепты" для контейнера сервисов. В провайдерах сервисов ты указываешь, как создавать и настраивать объекты (байндить их)

>  Если класс A требует использования класса B, провайдер сервисов говорит контейнеру: "Когда создаешь объект класса A, используй класс B в качестве одного из ингредиентов".

Контейнер зависимостей == service container

* Контейнер зависимостей использует байндинги для связывания **интерфейсов** с их реализациями.

```php
// Пример байндинга
$this->app->bind(FileWriterInterface::class, FileWriter::class);

$this->app->bind(Logger::class, function ($app) {
    return new Logger($app->make(FileWriterInterface::class));
});
```

> Этот код говорит контейнеру: "Когда кто-то запрашивает объект Logger, создай его, используя функцию замыкания. При этом в конструктор Logger передай объект, созданный для интерфейса FileWriterInterface".


* Переменная $app в Laravel представляет собой сам контейнер зависимостей. 

Т.е. когда ты видишь $app, это означает, что ты обращаешься к контейнеру для выполнения определенных задач

$app->make(FileWriterInterface::class) говорит контейнеру зависимостей создать объект, реализующий FileWriterInterface. 

$app->bin(...) используется для регистрации байндингов в контейнере

* Байндинг - это инструкция , которая говорит контейнеру зависимостей, как создавать и предоставлять объекты в твоем приложении

Когда твое приложение запрашивает объект (например, класс), контейнер зависимостей Laravel использует байндинги для понимания, какой класс использовать и какие зависимости (другие объекты) передать ему при создании.

Пример байндинга:

```
$this->app->bind(Logger::class, function ($app) {
    return new Logger($app->make(FileWriterInterface::class));
});

```


> В этом примере говорится: "Когда кто-то запрашивает объект класса Logger, создай его, используя функцию замыкания. При этом в конструктор Logger передай объект, созданный для интерфейса FileWriterInterface". Здесь Logger::class - это абстракция (как интерфейс), и мы связываем ее с конкретной реализацией, указанной в функции замыкания.

```
$this->app->bind(FileWriterInterface::class, FileWriter::class);
```

Этот код говорит Laravel, как создавать объекты, когда встречается запрос на интерфейс FileWriterInterface. 

$this->app: Это ссылка на контейнер зависимостей Laravel. Мы обращаемся к нему, чтобы сказать, как управлять созданием объектов.

bind(...): Это метод контейнера, который используется для установки байндингов. В данном случае, мы говорим: "Когда кто-то запрашивает объект, реализующий интерфейс FileWriterInterface, используй класс FileWriter"


FileWriterInterface::class: Это указание на интерфейс, для которого мы хотим установить байндинг. Это абстракция, которую используем в коде, чтобы обозначить тип объекта.

FileWriter::class: Это конкретная реализация, которую мы связываем с интерфейсом. Таким образом, когда запрос идет на FileWriterInterface, Laravel создает объект класса FileWriter

Итак, эта строка кода устанавливает правило для контейнера зависимостей: при запросе объекта, реализующего FileWriterInterface, используй класс FileWriter. Это делает код более гибким и облегчает замену конкретной реализации интерфейса в будущем.


#### Начало документации по биндам

Почти все твои бинды (bindings) контейнеров зависимостей (service conttainer) будут зареганы внутри service providers















