# Docker бля...

## Краткий Обзор

* Kunteynir - это изолированный процесс, выполняющийся на хост-компе, котрый изолирвоан от всех других процессов, запущенных на этом хост-компе.

Контейнер - это исполняемый экземпляр образа. Его можно, там, создавать, стартовать/стопать и прочее. Может запускаться на локалке, виртуалке или деплоиться в облако. Портабелен и независим от ОС. Изолирован от других контейнеров и запускает свой собственный софт, бинарники конфиги и прочее.

Запущенный контейнер использует изолированную файловую систему.

* Образ (Image) - предоставляет контейнеру изолированную файловую систему.

Образ должен в себе содержать все инструменты для запуска программы - все зависимости, конфиги, скрипты и прочее. Также глобальные переменные, дефолтные команды для запуска и прочие метаданные.

## Контейнерим приложение

Чтобы построить образ, нужен Dockerfile. **В корне приложения**

* Dockerfile - простой текстовый файл без расширения, который содежрит в себе сценарий инструкций (script of instructions)

```
docker build -t *название_образа* *директория*
```

сначала загружается образ

после копируются инструкции из Dockerfile в приложение и используется yarn для установки зависимостей приложения. 

> CMD директива указывает команду для запуска по умолчанию, когда запускается контейнер с образом.

флаг -t типа походу используется для задачи имени для образа human-readable.

в конце указывается директория. Если уже в ней находишься, с докерфайлом в обнимку, ставь точку и не выёбывайся

```
docker run -dp 127.0.0.1:3000:3000 getting-started
```

-d флаг (--detach сокращение) запускает контейнер в фоновом режиме (in the background), ну типа демон не?

-p флаг принимает строковое значение в формате "HOST:CONTAINER", где HOST - адрес хоста, а CONTAINER - порт контейнера. 

> то есть команда выше публикует порт контейнера 3000 по адресу локалхоста.

ну и в конце название контейнера. Как назовешь контейнер, так он и полетит жидко обосравшись

List all containers: (Вывести все контейнеры)

```
docker ps
```

## Апдейтим приложение

Нельзя стартануть новый контейнер пока твой старенький работает. Птмшт старый всей жопой уселся на 3000 порт, а ведь только один процесс на компе (включая контейнеры) может прослушивать определенный порт.

то есть этот один определнный порт может прослушивать только один процесс.

чтобы это исправить, нужно удалить старый контейнер

* Перед тем как удалить контейнер, его нужно остановить.

1. Находим контейнер по **ID** с помощью **docker ps**

2. Вдавливаем **docker stop <id-контейнера>**

3. Вдавливаем **docker rm <id-контейнера>**

4. ???

> можно эту процедуру выполнить одной командой, добавив флаг force (-f) команде docker rm

```
docker rm -f <the-container-id>
```

теперь снова сначала билдим приложение, потом запускаем.

## Публикуем приложение

докер хаб все дела

```
docker push docker/getting-started:tagname
```

push a new image to repository: (replace tagname with your desired image repository tag)

```
docker tag local-image:tagname new-repo:tagname
docker push new-repo:tagname
```

в моём случае, при созданном репозитории getting-started:

```
docker push sl33pwalk/getting-started:tagname
```

* **docker image ls** - показать все образы

docker login -u *username*

Ну то есть перед пушем нужно задать тег

```
docker tag *название_образа_локальное* sl33pwalk/getting-started

docker push sl33pwalk/getting-started ```

### Запуск образа на новом экземпляре (instance)

чтобы перебилдить образ на платформу amd64, используем флаг --platform

```
docker build --platform linux/amd64 -t sl33pwalk/getting-started
```

можно в Play with Docker запустить образ который запушили

```
docker run -dp 0.0.0.0:3000:3000 YOUR-USER-NAME/getting-started
```

привязка к 127.0.0.1 открывает порты контейнера для интерфейса обратной петли/связи (loopback interface)

loopback interface - виртуальный интерфейс который всегда поднят и достигаем пока хотя бы один из IP интерфейсов работает на коммутаторе

* Loopback interface (интерфейс обратной петли) — это виртуальный сетевой интерфейс, который имитирует обычный сетевой интерфейс, но не связан с физическими портами или устройствами.

Loopback интерфейс обычно имеет IP-адрес 127.0.0.1 и маску подсети 255.0.0.0, что позволяетустройству обращаться к самому себе через этот интерфейс. 

Он может использоваться для проверки работоспособности сетевого стека, тестирования сетевыхприложений и настройки маршрутизации.


## Сохранение данных (Persist the DB)

Когда контейнер запускается, он использует различные слои образа для своей файловой системы. Также каждый контейнер имеет своё рабочее пространтсво (scratch space) для создания/обновления/удаления файлов. Любые изменения не будут видны в других контейнерах, даже если они используют один и тот же образ.

* Scratch space is space on the hard disk drive that is dedicated for storage of temporary user data. It is unreliable by intention and has no back up.


для доступа к контейнеру
```
docker exec ...

docker exec <container-id> cat /data.txt
```

docker run -it ubuntu ls /

-t - псевдо терминал

-i - оставляет STDIN открытым, даже если он не трогается

Ну типа, как я понял, вот в контейнеры на основе убунту мы записали файлы с рандомным числом, а в самом контейнере убунты их как не было, так и нет. И типа в этом суть скрэтч спейс?


docker run -d 

-d - detach, запустить контейнер в фоновом режиме и вывести ID контейнера

### Томы контейнера (Container volumes)

Любой контейнер начинается с определения образа каждый раз когда он запускается

Докер изолирует все те изменения, что были сделаны в контейнере, и оставляет образ нетронутым. 

Но с томами можно изменить это дерьмо

* Том (Volume) предоставляет возможность подключения определенных путей файловой системы из контейнера обратно к хост машине(?), ну типа позволяет добавить изменения

Если ты установишь директорию в контейнере, изменения в этой директории будут так же видны в хосте.

И если мы смонтируем ту же директорию при перезапуске контейнера, мы увидим те же файлы.

существует два типа томов, но об этом позже

* Создавая том и прикрепляя его (mounting) к директории, где хранишь данные, ты можешь сохранять свои данные =)

Volume mount - первый тип томов походу, первый подход

Думай (и богатей) о монтировании тома как и непрозрачном хранилище данных. 

Докер полностью управляет томом, включая место хранения на диске. Мне же нужно только запомнить имя тома.

1. создаем новый том 

```
docker volume create <название>
```

2. Стопаем и удаляем контейнер если он еще запущен

3. стартуем новый контейнер, добавляя опцию --mount для задания тома (volume mount). Даем тому название и монтируем его по нужному адресу в контейнер. 

```
docker run -dp 127.0.0.1:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started
```

* Чтобы посмотреть, где хранятся данные тома, вводим **docker volume inspect**

Чтобы войти в файловую систему контейнера:
```
docker exec -it <container-id> sh
```

> exit чтобы выйти


## Use bind mounts (Используй привязки маунтов)


В прошлой части мы юзали volume mount для сохранения данных в бд. Volume mount - хороший выбор, когда нужно постоянное место для хранения данных приложения.

* Bind mount это еще один тип маунта, который позволяет делиться директориями из файловой системы хоста с контейнером. 

можно юзать бинд маунт чтобы подмонтировать исходный код в контейнер.

То есть можно запускать процессы в контейнере, которые будут смотреть за изменения в файловой системе и отвечать на них определнным образом.


Разница между volume mount и bind mount

+ Volume mount:

    + Host location выбирает сам докер

    + src=название_тома

    + type=volume,src=my-volume,target=/usr/local/data

    + Заполняет новый том  (volume) содержимым контейнера

    + поддерживает драйвера тома (Volume Drivers)

+ Bind mount:

    + Host location выбираешь ТЫ САМ

    + src=путь/до/данных

    + type=bind,src=/path/to/data,target=/usr/local/data

    + Не заполняет

    + Не поддерживает драйвера тома (?)


стартуем баш в бубунту контейнере с помощью bind mount:

```
docker run -it --mount type=bind,src="$(pwd)",target=/src ubuntu bash
```

опция --mount говорит докеру, чтобы он создал bind mount, где src это текущая рабочая директория на нашей хост-машине (getting-started-app если по докам), и target это где должна появиться эта директория внутри контейнера (/src в моём случае)


Теперь, при переходе в созданную директорию в контейнере, если создать там новый файл, то он появится и у нас на хост-машине, ну то есть у нас на компе. Прикол.


bind mount-ы обычно используются для локальных сетапчиков. Преимущество в том, что development machine (машина разработки звучит пошловато) не обязана заранее иметьб все инструменты и окружения. С помощью docker run докер пулит зависимости и инструменты в контейнер, я так понял.

### Run your app in a development container

```
docker run -dp 127.0.0.1:3000:3000 \
    -w /app --mount type=bind,src="$(pwd)",target=/app \
    node:18-alpine \
    sh -c "yarn install && yarn run dev"
```

запускаем в фоновом режиме и назначаем порты

-w /app - устанавливаем рабочую директорию из текущей директории

--mount type=bind,src="$(pwd)",target=/app - bind mount текущей директории из хоста в /app директорию в контейнере

node:18-alpine - образ, который будем использовать. 

sh -c "yarn install && yarn run dev" - команда обычная. sh запускает shell (в alpine linux нет баша) и запускаем yarn install для установки пакетов и затем запускаем yarn run dev для запуска сервера разработки. 

> если в проекте из доков заглянуть в package.json, то можно увидеть что dev скрипт запускает nodemon

Посмотреть логи:

```

docker logs -f <container-id>

```
docker rmi -f <image-id>
```

rmi - Удалить образ (image)
-f - force





