# Laravel Documentation

# Getting Started + Architecture Concepts

Значит так, директории делятся на два типа:

### The Root Directory
  The app Directory
  The bootstrap Directory
  The config Directory
  The database Directory
  The public Directory
  The resources Directory
  The routes Directory
  The storage Directory
  The tests Directory
  The vendor Directory

### The App Directory
  The Broadcasting Directory
  The Console Directory
  The Events Directory
  The Exceptions Directory
  The Http Directory
  The Jobs Directory
  The Listeners Directory
  The Mail Directory
  The Models Directory
  The Notifications Directory
  The Policies Directory
  The Providers Directory
  The Rules Directory


ух бля... ну погнали

начинаем с рута

* директория **app** содержит в себе ядро кода нашего приложения. Почти все классы в твоем приложении будут находиться именно там.

* директория **bootstrap** содержит файл *app.php*, который автозагружает фреймворк (?). Также в этой директории поселилась **cache** директория, ну она для оптимизации типа понятное дело. Тебе здесь не рады, ничего здесь не меняй.

* директория **config**, по названию уже понятно, что в себе содержит. Действительно, было бы неплохо если бы ты туда заглянул посмотрел, но... идем дальше

* директория **database** содержит в себе миграции бд, заводы модельные (ну вроде типа чтобы заполнить данными). Также можно там держать SQLite базу данных.

* **public** содержит *index.php* файл, который является входной точкой для всех реквестов, входящих в твое приложение и настраивает автозагрузку. В этом каталоге так же хранятся различные ассеты по типу картинок, js css. 

* **resources** содержит views (представления), а также сырые, некомпилированные ассеты по типу css и js.

* **routes** содержит все определения маршрутов приложения. По дефолту, в ларавеле включено несклько маршрутов: web.php, api.php, console.php и channels.php

  + **web.php** содержит маршруты, которые RouteServiceProvider помещает в группу веб-промежуточного ПО (web middleware), которое обеспечивает состояние сессии (?), CSRF защиту и шифрование куки. Если моё приложение не предлагает stateless, RESTful API, тогда все мои руты скорее всего будут определены именно в **web.php**.

  + **api.php** содержит маршруты, которые RouteServiceProvider помещает в группу *api middleware*. Эти маршруты предназначены для того, чтобы быть *stateless* (ааа, stateless это значит, что состояние не хранится на сервере), поэтому реквесты, заходящие в приложение через эти маршруты должны быть авторизованы через токены и не будут иметь доступ к session state (состояние сессии(?)).

  + **console.php** - файл, где мы определяем все наши замыкания, основанные на консольных командах. Каждое замыкание привязано к экземпляру команды, что обеспечивает простой подход к взаимодействию с методами ввода-вывода (IO methods) каждой команды. Несмотря на то, что этот файл не определяет HTTP маршруты, он определяет основанные на консоли входные точки (маршруты) в твоём приложении.

  + **channels.php** - файл, где можно зарегистрировать все каналы трансляции событий, которые поддерживает наше приложение.

* **storage** содержит логи, blade шаблоны скомпилированные, сессии (file based), кэш и многое другое, сгенерированное фреймворком. Ну сральня офк. Директория поделена на app, framework и logs директории. 


КОРОЧЕ, ПОТОМ ДОБИВАЙ ЭТО, Я НАСТОЯЩИЙ СЕЙЧАС ЗАЕБАЛСЯ

## Обзор жизненного цикла (Lyfecycle Overview)

### Первые Шаги

Точкой входа для всех реквестов, направленных на приложение Laravelm, является *public/index.php*. 

Все реквесты направляются в этот файл благодаря конфигурации твоего веб-сервера (Apache, Nginx)

*index.php* загружает сгенерированные Composer-ом определения автозагрузки, и затем получает экземпляр Laravel приложения из файла *bootstrap/app.php*

Первым делом laravel создаст экземпляр приложения / service container

### HTTP / Консольные ядра (Console Kernels)

После первых шагов, входящий запрос отправляется или в HTTP Kernel или в Console Kernel, это зависит типа запроса, который входит в программу (?)
 
Эти карты, деньги, два ядра служат центральной прослойкой, через которую проходят все запросы.
 
HTTP: *app/Http/Kernel.php*
 
* HTTP ядро наследует (extends) класс *Illuminate\Foundation\Http\Kernel*,  который определяет массив из бутстраперов, которые будут запущены перед тем, как выполнится запрос.
 
Бутстраперы конфигурируют error handling, logging, определяют окружение приложения и прочее.

> обычно, эти классы обрабатывают внутреннюю конфигурацию Laravel, о которой нам не нужно беспокоиться

* Также HTTP ядро определяет список *HTTP middleware*, через который все запросы должны пройти перед их обработкой приложением.

* Middleware (промежуточное ПО) обрабатывает чтение и запись HTTP сессии

### Service Providers (Поставщики Услуг)

* Service Providers ответственны за bootstrapping (начальную загрузку) всех компонентов фреймворка, по типу бд, запрос, валидация и прочее. 

Все service providers конфигурируются в *config/app.php* файле, в массиве *providers*

Laravel поэтапно пройдет через этот список провайдеров/поставщиков и создаст экземпляр для каждого/

* Экземпляр класса (instance) - это описание конкретного объекта в памяти

После создания экземпляра провайдеров, будет вызван метод *register* для всех поставщиков.

Затем, после того, ка все провайдеры будут зарегистрированы, метод *boot* будет вызван так же для всех провайдеров. 

Это сделано для того, чтобы service providers могли зависеть от того, что каждая привязка контейнера будет зарегистрирована и доступна к моменту выполнения метода *boot*

Service Providers - самый важный аспект всего Laravel bootstrap процесса.

### Routing (Маршрутизация)

* Service provider *App\Providers\RouteServiceProvider* загружает файлы маршрутов, которые находятся внутри директории *routes* нашего приложения

После того, как приложение было загружено (bootstrapped) и все service providers были зарегистрированы, будет передан *Request* маршрутизатору для отправки.

Маршрутизатор отправит запрос на маршрут (route) или контроллер, а также запустит любое промежуточное ПО (middleware), специфичное для маршрута.

Если запрос пройдет через всё назначенное middleware соответствующего маршрута, метод контроллера или маршрута будет выполнен и ответ, возвращенный методом маршрута или контроллера, будет отправлен обратно через цепочку middleware

### Подвод итогов

Как только маршрутный или контроллерный метод возвращает ответ, ответ отправится в путешествие обратно через маршрутное middleware, давая приложению возможность модифицировать или проверить исходящий ответ. 

Как итог, как только ответ пройдет обратно через middleware, метод handle ядра HTTP возвратит объект ответа, а файл *index.php* вызовет метод *send* на возвращенный ответ. Метод *send* отправляет содержимое ответа в броузер веб-юзера.


Service Providers - поистине ключ к загрузке приложения Laravel: создаётся экземпляр приложения, регистрируются service providers, и запрос передается загруженному приложению

Service providers по умолчанию хранятся в *app/Providers*

AppServiceProvider - место для создания собственных бутстрапперов и биндов. 


## Service Containers

* Service container - инструмент для управления зависимостями класса и выполнения внедрения зависимостей

Внедрение зависимостей - зависимости класса "внедрены" в класс через конструктор или, иногда, с помощью seter методов

### Zero Configuration Resolution (разрешение нулевой конфигурации)

Если у класса нет зависимостей или он зависит только от конкретных классов (не интерфейсов), то контейнеру не нужно указывать, как разрешить этот класс.

```php

<?php
 
class Service
{
    // ...
}
 
Route::get('/', function (Service $service) {
    die($service::class);
});

```

В примере выше переход к маршруту приложения "/" автоматически разрешит класс Service и внедрит его в обработчик вашего маршрута. 

### Когда использовать контейнера

Благодаря нулевому разрешению конфигурации (zero configuration resolution) вы часто будетет указывать зависимости в маршрутах, контроллерах, слушателях событий (event listeners) и других местах, никогда не взаимодействуя с контейнером вручную

Например, можно указать объект Illuminate\Http\Request в route definition (определение маршрута), чтобы легко получить доступ к текущему запросу. Несмотря на то, что нам никогда не придётся взаимодействовать с контейнером для написания этого кода, он управляет внедрением этих зависимостей за кулисами:

```php

  use Illuminate\Http\Request;
 
  Route::get('/', function (Request $request) {
    // ...
});
```

Во многих случаях, благодаря автоматическим зависимостям и [фасадам](https://laravel.com/docs/10.x/facades), можно забилдить Laravel приложение без необходимости вручную связывать или разрешать что-либо из контейнера.

Если ты пишешь класс, реализующий интерфейс, и хочешь указать этот интерфейс в маршруте или конструкторе класа, ты должен указать контейнеру, как 
[разрешить этот интерфейс](https://laravel.com/docs/10.x/container#binding-interfaces-to-implementations)

## Binding (привязка/связывание)

* Контейнер зависимостей - инструмент для управления зависимостями и внедрения зависимостей

* Binding - способ сообщить контейнеру, как создавать экземпляры классов и как ими управлять

Bindind - это как рецепт для создания объекта

* Представим, что есть рецепт (байндинг), чтобы приготовить определённое блюдо (объект). Когда ты хочешь это блюдо, ты следуюешь рецепту, используя нужные ингредиенты (зависимости)

Пример:

Пишем рецепт:
> Если кто-то попросит объект класса А, используй функцию, которая создает его и добавляет нужные ингредиенты

Когда нужен объект, мы говорим контейнеру: Дай мне объект класса А. 

Laravel использует твой рецепт, чтобы приготовить и вернуть тебе объект

Регистрация:

```php

// В файле, где регистрируются байндинги, например, app/Providers/AppServiceProvider.php

use App\Services\MyService;

public function register()
{
    $this->app->bind(MyService::class, function ($app) {
        // Создаем объект MyService и добавляем нужные ингредиенты (зависимости)
        return new MyService($app['SomeDependency']);
    });
}
```

Запрос объекта:

```
// Когда тебе нужен объект MyService
$myService = app(MyService::class);
```

байндинги - это способ управлять объектами. 

Почти все связи (bindings) в контейнере сервисов будут создаваться и настраиваться внутри провайдеров сервисов.


* **Контейнер зависимостей** - это такое хранилище, где Laravel держит информацию о том, как создавать и предоставлять объекты

> если твое приложение говорит "Мне нужен объект класса А", контейнер сервисов отвечает "Понял, создам для тебя объект класса А с учетом всех нужных деталей"

* **Провайдер сервисов** - Это как "мастер-повар", который подготавливаем "рецепты" для контейнера сервисов. В провайдерах сервисов ты указываешь, как создавать и настраивать объекты (байндить их)

>  Если класс A требует использования класса B, провайдер сервисов говорит контейнеру: "Когда создаешь объект класса A, используй класс B в качестве одного из ингредиентов".

Контейнер зависимостей == service container

* Контейнер зависимостей использует байндинги для связывания **интерфейсов** с их реализациями.

```php
// Пример байндинга
$this->app->bind(FileWriterInterface::class, FileWriter::class);

$this->app->bind(Logger::class, function ($app) {
    return new Logger($app->make(FileWriterInterface::class));
});
```

> Этот код говорит контейнеру: "Когда кто-то запрашивает объект Logger, создай его, используя функцию замыкания. При этом в конструктор Logger передай объект, созданный для интерфейса FileWriterInterface".


* Переменная $app в Laravel представляет собой сам контейнер зависимостей. 

Т.е. когда ты видишь $app, это означает, что ты обращаешься к контейнеру для выполнения определенных задач

$app->make(FileWriterInterface::class) говорит контейнеру зависимостей создать объект, реализующий FileWriterInterface. 

$app->bin(...) используется для регистрации байндингов в контейнере

* Байндинг - это инструкция , которая говорит контейнеру зависимостей, как создавать и предоставлять объекты в твоем приложении

Когда твое приложение запрашивает объект (например, класс), контейнер зависимостей Laravel использует байндинги для понимания, какой класс использовать и какие зависимости (другие объекты) передать ему при создании.

Пример байндинга:

```
$this->app->bind(Logger::class, function ($app) {
    return new Logger($app->make(FileWriterInterface::class));
});

```


> В этом примере говорится: "Когда кто-то запрашивает объект класса Logger, создай его, используя функцию замыкания. При этом в конструктор Logger передай объект, созданный для интерфейса FileWriterInterface". Здесь Logger::class - это абстракция (как интерфейс), и мы связываем ее с конкретной реализацией, указанной в функции замыкания.

```
$this->app->bind(FileWriterInterface::class, FileWriter::class);
```

Этот код говорит Laravel, как создавать объекты, когда встречается запрос на интерфейс FileWriterInterface. 

$this->app: Это ссылка на контейнер зависимостей Laravel. Мы обращаемся к нему, чтобы сказать, как управлять созданием объектов.

bind(...): Это метод контейнера, который используется для установки байндингов. В данном случае, мы говорим: "Когда кто-то запрашивает объект, реализующий интерфейс FileWriterInterface, используй класс FileWriter"


FileWriterInterface::class: Это указание на интерфейс, для которого мы хотим установить байндинг. Это абстракция, которую используем в коде, чтобы обозначить тип объекта.

FileWriter::class: Это конкретная реализация, которую мы связываем с интерфейсом. Таким образом, когда запрос идет на FileWriterInterface, Laravel создает объект класса FileWriter

Итак, эта строка кода устанавливает правило для контейнера зависимостей: при запросе объекта, реализующего FileWriterInterface, используй класс FileWriter. Это делает код более гибким и облегчает замену конкретной реализации интерфейса в будущем.

* Dependency Injection (внедрение зависимостей) - это практика, которая позволяет передавать зависимости (объекты, классы, сервисы и т. д.) в класс или метод, вместо того чтобы создавать их внутри этого класса или метода. Это помогает улучшить гибкость, тестируемость и обеспечивает более чистый код.

Пример внедрения зависимости в конструкторе класса в Laravel:

```php

class SomeClass
{
    protected $dependency;

    public function __construct(AnotherClass $dependency)
    {
        $this->dependency = $dependency;
    }

    public function someMethod()
    {
        // Используем зависимость
        $result = $this->dependency->doSomething();
        
        return $result;
    }
}

```

* В приведенном выше примере SomeClass зависит от AnotherClass, и этот зависимый класс передается через конструктор. Когда Laravel создает экземпляр SomeClass, он автоматически создает и внедряет экземпляр AnotherClass.

> Внедрение зависимостей упрощает тестирование, поскольку вы можете передавать поддельные (mock) объекты вместо реальных зависимостей во время тестирования, что делает тестирование более предсказуемым и изолированным.

#### Начало документации по биндам

В пределах service provider-а ты всегда будешь иметь доступ к контейнеру через **$this->app** свойство.

Мы можем зарегать бинд, используя **bind** метод, передав имя класса или интерфейса, котрый мы хотим зарегать, вместе с замыканием, которое возвращает экземпляр класса:

```php

use App\Services\Transistor;
use App\Services\PodcastParser;
use Illuminate\Contracts\Foundation\Application;
 
$this->app->bind(Transistor::class, function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
});

```

## Короче, сначала я не понял ничего, потом показалось, будто бы начал понимать, теперь снова ничего не понимаю. Вернусь к биндам уже когда буду более закалён.


* Фасад - это класс, который предоставляет доступ к объекту через контейнер.


# The Basics

## Routing (маршрутизация)

самые базовые маршруты принимают URI и замыкание, предоставляющее простой метод определения маршрутов и поведения без сложных файлов конфигурации маршрутов

```php

use Illuminate\Support\Facades\Route;
 
Route::get('/greeting', function () {
    return 'Hello World';
});

```

Все маршруты определены в *routes* директории. Эти файлы автоматически загружаются с помощью *App\Providers\RouteServiceProvider*

* *routes/web.php* файл определяет руты для веб интерфейса. Этим рутам назначена web группа middleware, предоставляющая приколы по типу CSRF защиты и session state (состояние сеанса)

*routes/api.php* stateless и им назначена api группа middleware

* руты, определнные в *routes/web.php* могут быть доступны, пройдя определенному адресу URL в броузере. 

* руты, определенные в *routes/api.php* файле - вложены в группу маршрутов с помощью *RouteServiceProvider*

  * в этой группе автоматически применяется префикс */api* URI, поэтому не нужно вручную применять его к каждому маршруту в файле. 
  
  * Можно изменить префикс и другие параметры группы маршрутов, изменив свой класс *RouteServiceProvider*
  

### Available Router Methods (Доступные методы роутера)

Роутер позволяет зарегать руты, отвечающие на любой HTTP метод

```php
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);
```

Иногда бывает нужным зарегистрировать ответы для множества HTTP методов. Для этого можно воспользоваться методом *match*. Или же можно зарегистрировать рут, который будет отвечать на все HTTP методы (verbs), используя метод *any*

```php
Route::match(['get', 'post'], '/', function () {
    // ...
});
 
Route::any('/', function () {
    // ...
});
```

* при определении нескольких маршрутов, имеющих один и тот же URI, маршруты, использующие методы get/post/put/patch/delete/options должны быть определены до маршрутов, использующих методы any/match/redirect. Это гарантирует, что входящий запрос будет сопоставлен с правильным маршрутом. 

### Внедрение зависимостей (dependency injection)

Ты можешь указать любые зависимости, которые нужны твоему руту в сигнатуре обратного вызова маршрута (callback функции (функции обратного вызова))

* callback функции могут быть как простыми функциями, так и методами объектов, включая статические методы классов. Также в callback-функции можно передавать анонимные функции и стрелочные функции

* ну то есть callback функция - это функция, которая передается другой функции в качестве аргумента и вызывается этой функцией по окончании определенного блока инструкций (thx hexlet)

Объявленные зависимости автоматически будут разрешены и внедрены в callback (обратный вызов) с помощью *service container*

Например, можно указать класс *Illuminate\Http\Request* чтобы автоматически внедрить текущий HTTP запрос в обратный вызов (callback):

```php
use Illuminate\Http\Request;
 
Route::get('/users', function (Request $request) {
    // ...
});
```


### CSRF защита

Все HTML-формы, указывающие на маршруты POST/PUT/PATCH или DELETE, которые определены в файле *web* маршрутов, должны содержать CSRF token field (поле токена CSRF).

Иначе, запрос получит ~~(по ебалу)~~ отказ.

```php
<form method="POST" action="/profile">
    @csrf
    ...
</form>
```

### Redirect Routes (перенаправление рутов)

Если ты определяешь рут, который редиректит на другой URI, то можно использовать метод **Route::redirect**. Этот метод предоставляет шорткат, благодаря которому не нужно определять целый рут или контроллер для простого редиректа. 

```php
Route::redirect('/here', '/there');
```

* URI - laravel.com/docs/10.x/routing

* URL - laravel.com

* URN - docs/10.x/routing

По дефолту *Route::redirect* возвращает код 302. Этот код можно изменить, добавив третий аргумент.

```php
Route::redirect('/here', '/there', 301);
```

Или можно использовать **Route::permanentRedirect** метод для возвращения кода 301:

```php
Route::permanentRedirect('/here', '/there');
```

> При использовании параметров маршрута в редиректах следующие параметры зарезервированы Laravel и не могут быть использованы: *destination* и *status*

### View Routes (руты представлений)

Если руту нужно только вернуть представление (view), можно заебашить простой метод **Route::view**. Аналогичен методу *redirect*, т.е. прост шорткат. 

*view* метод принимает URI как первый аргумент и название представления вторым аргументом. 

> Как дополнение, можно передать третий опциональный аргумент, массив данных, который будет предоставлен представлению

```php
Route::view('/welcome', 'welcome');
 
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);
```

* в таких рутах представлений нельзя использовать следующие параметры: view, data, status и headers, ну это походу эти ->view() и прочее.

### The Route List

```php
php artisan route:list
```

предоставляет обзор всех рутов, которые определены в приложении

  По умолчанию не выводит middleware руты и имена групп. Можно вывести, добавив  патриотическую опцию -v , или -vv для расширенного вывода
  
Также можно вывести ток маршруты с определенным URI:

```
php artisan route:list --path=api
```

Спрятать руты, определенные третьими лицами: --except-vendor

если только третьи лица нужны: --only-vendor


## Route Parameters (Параметры рутов)

### Required Parameters (Обязательные параметры)

Иногда может понадобиться взять сегмент из URI к себе в код.

Пример: нужно взять ID юзера из URl:

```php
Route::get('/user/{id}', function (string $id) {
    return 'User '.$id;
});
```

Количетсво обязательных параметров неограниченно:

```php
Route::get('/posts/{post}/comments/{comment}', function (string $postId, string $commentId) {
    // ...
});
```

Route параметры всегда заключены в фигурные скобки {} и лучше бы им состоять из букв алфавита. Нижнее подчеркивание также доступно внутри названия параметра.

* Параметры маршрута внедряются в обратные вызовы маршрута/контроллеры **на основе их порядка** - имена аргументов обратных вызовов маршрута / контроллеров не имеют значения.

### Параметры и Внедрения зависимостей

Сначала зависимости, потом параметры маршрута

```php
use Illuminate\Http\Request;
 
Route::get('/user/{id}', function (Request $request, string $id) {
    return 'User '.$id;
});
```

### Необязательные параметры

Допустим, нужно создать рут параметр, который не всегда присутствует в URI. Тогда мы просто добавляем знак ? после названия параметра и дефолтное значение ставим. 

```
Route::get('/user/{name?}', function (?string $name = null) {
    return $name;
});
 
Route::get('/user/{name?}', function (?string $name = 'John') {
    return $name;
});
```

### Regular Expression Constaints (Ограничения регулярных выражений)

